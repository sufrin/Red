FROM EditSessionCommands

   /** Employed in implementing cursor-drag selections.
    *  The undo must reset the selection
    */
  def setCursorAndMark(row: Int, col: Int): SessionCommand = new SessionCommand {
    def DO(session: EditSession): StateChangeOption = {
      val oldCursor = session.cursor
      val oldSelection = session.selection
      Some {
        new StateChange {
          def undo(): Unit = { session.selection = oldSelection; session.cursor = oldCursor }
          def redo(): Unit = {
              session.setCursorAndMark(row, col)
          }
          locally { redo() }
        }
      }
    }
  }

  /**
   *  Dragging the cursor is unusual.
   *  There is no need for a history item, because a drag will always be
   *  preceded by a `setCursorAndMark`, and followed by a `mouseUp`
   *  whose undo method will suffice to undo the whole drag sequence, and
   *  whose redo method simply restores the selection as it was at the point the mouse
   *  was released.
   *
   *  '''TL;DR '''
   *  In any case, having a history item per drag event would be
   *  costly in terms of space and bandwidth: even if the drags were (as they
   *  should be) merged.
   */
  def dragCursor(row: Int, col: Int): SessionCommand = new SessionCommand {
    def DO(session: EditSession): StateChangeOption = {
      session.dragCursor(row, col)
      None
    }
  }

  /**
   *  The end of a sequence of cursor drags is recorded
   *  in the history as if it were a single selection
   *  event.
   *
   */
  val mouseUp: SessionCommand = new SessionCommand {
    def DO(session: EditSession): StateChangeOption = {
      if (session.draggingFrom.isEmpty)
         None
      else Some (new StateChange {
          val oldCursor    = session.draggingFrom.get
          val oldSelection = session.selection
          session.stopDragging
          def undo(): Unit = { session.cursor = oldCursor; session.selection = NoSelection }
          def redo(): Unit = { session.cursor = oldSelection.cursor; session.setMark(oldSelection.mark) }
      })
    }
  }
  
// FROM The mouse handler in EditSessionHandlers.scala

        case MouseReleased(_, _,       Button1)           => DO(commands.mouseUp)
        
// AND FROM InputPanel.scala WHERE THE MOUSE RELEASED METHOD HAD BEEN WRONG BUT UNUSED

override def mouseReleased(e: MouseEvent): Unit = {
        // A mouse button was released
        /* OS/X Java uses alt/ctrl/meta keys
         * to encode the button, as well as reporting the
         * released button -- so we must not use these
         * modifiers-keys-proper when reporting from
         * here.
         */
        val (row, col)  = viewToModel(e.getPoint)
        val button      = e.getButton match {
          case 1 => Modifiers.Button1
          case 2 => Modifiers.Button2
          case 3 => Modifiers.Button3
          case _ => Modifiers.NoModifier // TODO: Log this
        }
        if (logging) finest(s"REL($button) ${metaToControl(Detail(e.getModifiersEx))}")
        // TODO: need to be able to work with >3-button mice
        mouseInput.notify(MouseReleased(row, col, button))
      }
  

// AND IN  EditSession.scala

  var draggingFrom: Option[Int] = None

  def stopDragging: Unit = { draggingFrom = None }

  /**
   * Set the cursor whilst preserving the current mark, if there is one.
   * Notify observers of changes in the selection/cursor.
   */
  def dragCursor(row: Int, col: Int): Unit = {
    if (logging)
      finer(s"DragCursor($row, $col) with selection=$selection")
    val newcursor = document.coordinatesToPosition(row, col)
    if (draggingFrom.isEmpty) draggingFrom = Some(cursor)
    cursor=newcursor
    if (selection ne NoSelection) selectUntil(selection.mark)
  }
