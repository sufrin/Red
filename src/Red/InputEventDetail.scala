package Red

/** A grab-bag of tools to support the simple and intelligible decoding of
  * `MouseButtonEvent`s and `KeyEvent`s generated by the underlying platform, as
  * well as the `InputEvent`s into which they are translated by
  * `InputPanel`s and their descendants.
  *
  * A typical use, in the scope of `InputEventDetail._`, might be
  * {{{
  *    mods.hasButton1 || mods.hasMeta  || mods.hasControl
  * }}}
  * or its equivalent
  * {{{
  *   mods.hasAny(Buttons.Button1|Buttons.Meta|Buttons.Control)
  * }}}
  *
  * The "little language" of modifiers is made less clumsy by implementing some
  * methods as part of an "implicit extension" to the `Int` type. Compare the
  * use of the implicit `mods.hasAlt` to the hasAlt(mods)` that would
  * be necessary with the more "orthodox" definition
  * {{{
  *   def hasAlt(mods: Int): Boolean = (mods & Modifier.Alt) != 0
  * }}}
  */
object InputEventDetail {

  implicit class ImplicitExtensions(val mods: Int) extends AnyVal {
    def hasAlt: Boolean     = (mods & Modifier.Alt) != 0
    def hasMeta: Boolean    = (mods & Modifier.Meta) != 0
    def hasShift: Boolean   = (mods & Modifier.Shift) != 0
    def hasControl: Boolean = (mods & Modifier.Control) != 0
    def hasButton1: Boolean = (mods & Button.Button1) != 0
    def hasButton2: Boolean = (mods & Button.Button2) != 0
    def hasButton3: Boolean = (mods & Button.Button3) != 0

    def hasAll(bitMask: Int): Boolean  = (mods & bitMask) == bitMask
    def hasAny(bitMask: Int): Boolean  = (mods & bitMask) != 0
    def hasNone(bitMask: Int): Boolean = (mods & bitMask) == 0

    def asText: String = {
      val b = new StringBuilder
      if (mods.hasControl) b.append("ctrl+")
      if (mods.hasShift) b.append("shift+")
      if (mods.hasAlt) b.append("alt+")
      if (mods.hasMeta) b.append("meta+")
      if (mods.hasButton1) b.append("Button1+")
      if (mods.hasButton2) b.append("Button2+")
      if (mods.hasButton3) b.append("Button3+")
      b.toString
    }
  }

  /** Declare the individual mouse button masks, so they can be imported en-bloc
    */
  object Buttons {
    import java.awt.event.InputEvent._
    val Button1: Int = BUTTON1_DOWN_MASK
    val Button2: Int = BUTTON2_DOWN_MASK
    val Button3: Int = BUTTON3_DOWN_MASK
  }

  /** Alias for `Buttons`: to be used as a prefix `Button.Button2`, etc.
    */
  val Button: Buttons.type = Buttons

  /** Alias for `swing.event.key`: to be used as a prefix `Key.A, Key.Numpad0`,
    * etc.
    */
  val Key: swing.event.Key.type = swing.event.Key

  /** Alias for `Key.Modifier`: to be used as a prefix, eg. `Modifier.Shift`
    */
  val Modifier: Key.Modifier.type = Key.Modifier

  /** Declare the individual modifier shift masks so they can be imported
    * en-bloc
    */
  object Modifiers {
    val Control: Int  = Modifier.Control
    val Shift: Int    = Modifier.Shift
    val Alt: Int      = Modifier.Alt
    val AltGraph: Int = Modifier.AltGraph
    val Meta: Int     = Modifier.Meta
    val NoModifier: Int    = 0
    val ControlShift: Int  = Control|Shift
    val ControlMeta: Int   = Control|Meta
  }

  /** Enumeration of the various keyboard locations */
  val Location: Key.Location.type = Key.Location
}
