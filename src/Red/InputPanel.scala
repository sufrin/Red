package Red

import java.awt.Cursor
import java.awt.event.KeyEvent._
import java.awt.event._
import scala.swing.event.{FocusGained, FocusLost}
import scala.swing.{Component, Container}

/**
 * A `Panel` that:
 *
 * 1. adapts the standard swing keystroke event
 * machinery for use by our (simpler) `UserInput`
 * notification and handling machinery.
 *
 * 2. adapts the standard swing mouse event machinery
 * for use by our (simpler) `UserInput`
 * handling machinery.
 *
 * 3. handles sensibly (by internally defined
 * overrideable defaults) the most common events generated
 * on it by focus and size change events.
 *
 * '''Operation:'''
 *
 * `keyPressed` events are captured early, independently of
 * `scala.swing` then translated  directly into
 * `UserInput.Instruction`s or `UserInput.Character`s that are
 * notified from its `keystrokeInput: Notifier[UserInput]`.
 * These can be handled directly by client programs using
 * `UserInputHandler`s.
 *
 * The benefits of this adaptation are:
 *
 * 1. (The many) irrelevant `KeyEvent`s reported by the
 *    underlying `java.swing` toolkit are
 *    just ignored.
 *
 * 2. "well-known" instruction keys (delete, rubout, tab, etc) --
 *    usually, but not always,  delivered as ascii keys in the control-character
 *    range -- are consistently translated into `UserInput.Instruction`s.
 *
 * 3. A large variety of keystrokes are distinguished, and this
 *    means that individual users' tastes in keyboard layout
 *    can very frequently be catered for.  Although the present
 *    implementation is intended to support a systematic approach
 *    to keyboard layout, there is no reason
 *    why keystrokes that are initially mapped to `Instruction`s
 *    cannot be mapped to character insertions by clients.
 *
 *
 *
 * Any modifier keys (Alt, Meta, Shift, Control, ...) or buttons down at the time of a
 * keystroke are passed on as part of the `modifiers` field of the `Instruction` or
 * `Character`. This has the value type `UserInputDetail.Detail`, and that type has a rich
 * set of methods for interrogating them, as well as constants that can be used
 * in straightfoward matching.
 *
 * The same holds holds for the reporting of mouse events.
 *
 * It is assumed that any keys typed with a `Control` or
 * `Meta` (OS/X=Cmd) modifier key down are intended to denote
 * `Instruction`s  whether or not any other modifier
 * key (Shift or Alt) is down.
 *
 *
 * '''Rationale'''
 *
 * 1. The (antiquated) Java scheme for handling keyboard events is confusing
 *    and hard to use -- perhaps unsurprising in light of the variety
 *    of keyboards and keyboard encodings it must handle, and the
 *    numbers of operating systems for which it has to maintain a
 *    semblance of consistent behaviour.
 *
 *    The `scala.swing` adoption of this model inherits many of the
 *    most confusing aspects of the design, though its (admirable)
 *    publisher machinery is an advance on the Java scheme.
 *
 * 2. The remaining interesting events generated by Panels are
 *    also handled here so as to enable client programs to be
 *    be built straightforwardly without having to use both
 *    the scala.swing publication model and our
 *    preferred, somewhat simpler, model of `UserInput` events
 *    notified from typed `Notifier`s, and
 *    handled by `UserInputHandler`s.
 *
 * @param numPadAsCommand Treat the numeric keypad (to the right of the
 *                        normal keyboard on some larger keyboards) as
 *                        a source of `Instruction`s rather than
 *                        `Character`s.
 *
 *
 * @param mapMeta  When this is true, the `Meta` (OS/X "Cmd") and
 *                  `Control` modifiers are both mapped to `Control`.
 *                  This simplifies the design of OS-agnostic
 *                  keystroke handlers in clients, at the expense of
 *                  limiting the number of distinct `Instruction`s
 *                  available to them.
 *
 * @param mergeMouseInput When true (the default), mouse and keyboard
 *                        input events are both notified from the `keystrokeInput`
 *                        `Notifier`.
 *
 *
 *  TODO: solve the "force focus here" problem. THis is likely to be
 *        a systemic problem that cannot be solved locally.
 *
 */


abstract class InputPanel(val numPadAsCommand: Boolean = UserInput.numpadAsCommand,
                          val mapMeta:         Boolean = UserInput.mapMeta,
                          val mergeMouseInput: Boolean = true,
                          )
  extends Component
     with Container.Wrapper {

  import InputPanel._
  import UserInputDetail._

  /** Link to an underlying `javax.swing.JPanel` to provide most
   *  of the functionality of this component
   */
  override lazy val peer: javax.swing.JPanel = new javax.swing.JPanel with SuperMixin

  locally { peer.setFont(font) }

  /** When true, the numeric keypad is treated as a source of `Instruction`s
   * rather than `Character`s.
   */
  var numpadAsCommand: Boolean = true

  /**
   * Transform the given event `modifier` bits so that  the `Meta`
   *  bit (OS/X `Cmd`) is mapped directly to the `Control` bit iff
   *  the component was constructed in `mapMeta` mode. In this
   *  mode the `Meta` and `Control` shifts cannot be distinguished,
   *  they are both reported as a `Control` shift.
   */
  private def metaToControl(detail: Detail): Detail =
          if (mapMeta) detail.mapMeta else detail


  /**
   * Notifier of the details of keystrokes made when
   * this `Component` has the input focus.
   *
   * Here are some examples of keystrokes and the corresponding `UserInput`
   * that gets notified, via `keystrokeInput`.
   * {{{
   * KEY    keyChar       Notified      (modifiers.asText)+
   *                      Class         Key (or character)
   * -------------------------------------------------------
   * A      'a'        => Character     'a'
   * B      'b'        => Character     'b'
   *
   * ctrl+A '\u0001'   => Instruction   control +Key.A
   * meta+A 'a'        => Instruction   meta+Key.A
   * meta+E 'e'        => Instruction   meta+Key.E
   * X      'x'        => Character     'x'
   * C      'c'        => Character     'c'
   * meta+X 'x'        => Instruction   meta+Key.X
   * X      'x'        => Character     'x'
   * F1                => Instruction   Key.F1
   * F2                => Instruction   Key.F2
   * ctrl+F1           => Instruction   control +Key.F1
   * alt+F3            => Instruction   alt+Key.F3
   * ctrl-alt+F3       => Instruction   control +alt+Key.F3
   *
   * On OS/X with a standard British keymap (and an empty `altKeyChar`) map
   * alt+X  '≈'        => Character alt+'≈' // OS/X British
   * alt+C 'ç'         => Character alt+'ç' // OS/X British
   * alt+meta+X '≈'    => Instruction alt+meta+X
   * }}}
   *
   * Decodings of keys typed on/at the numeric pad
   * {{{
   * NumPad-1       '1'      => Instruction Numpad1
   * NumPad-2       '2'      => Instruction Numpad2
   * ctrl+NumPad-0  '0'      => Instruction control+Numpad0
   * ctrl+NumPad .  '.'      => Instruction control+NumPad .
   * ctrl+Enter     '\u000a' => Instruction control+Enter
   * ctrl+NumPad +  '+'      => Instruction control+Add
   * }}}
   */
  val keystrokeInput: Notifier[UserInput] = new Notifier[UserInput] {
    override def enableResources(): Unit = {
      peer.addKeyListener(Keyboard.listener)
      if (mergeMouseInput) {
        peer.addMouseListener(Mouse.listener)
        peer.addMouseMotionListener(Mouse.motionListener)
      }
    }
    override def disableResources(): Unit = {
      peer.removeKeyListener(Keyboard.listener)
      if (mergeMouseInput) {
        peer.removeMouseListener(Mouse.listener)
        peer.removeMouseMotionListener(Mouse.motionListener)
      }
    }
  }

  /**  Notifier of (most of the) mouse inputs made when this
   * component has the input focus.
   */
  val mouseInput:      Notifier[UserInput]  =
    if (mergeMouseInput) keystrokeInput else new Notifier[UserInput] {
      override def enableResources(): Unit = {
        peer.addMouseListener(Mouse.listener)
        peer.addMouseMotionListener(Mouse.motionListener)
      }
      override def disableResources(): Unit = {
        peer.removeMouseListener(Mouse.listener)
        peer.removeMouseMotionListener(Mouse.motionListener)
      }
    }


  /////////////////////////// HANDLING KEYSTROKES ///////////////////////

  private object Keyboard {
    import AltKeyboard._
    // Bypass the `scala.swing.event` machinery for reporting keystrokes
    val listener: KeyAdapter = new KeyAdapter() {
      override def keyPressed(e: java.awt.event.KeyEvent): Unit = {
        val keyChar   = e.getKeyChar
        lazy val keyString = if (' '<= keyChar && keyChar <= 255) s"$keyChar" else f"\\u$keyChar%04x"
        val modifiers = e.getModifiersEx
        val detail    = Detail(modifiers)
        val location  = Key.Location(e.getKeyLocation)
        val keyCode   = e.getKeyCode
        val exKeyCode = e.getExtendedKeyCode
        if (logging)
          finest(s"'$keyChar' $modifiers $location $keyCode  $exKeyCode")
        if (e.isActionKey) {
          // one of the "standard" function keys
          val decoded =
              Instruction(Key(exKeyCode), location, metaToControl(detail))
          if (logging)
             fine(s"==> $decoded")
          keystrokeInput.notify(decoded)
        } else if (keyChar != CHAR_UNDEFINED) {
          // a character: not just a modifier-shift being pressed
          val decoded =
            keyChar match {
              case 27 =>
                Instruction(Key.Escape, location,      metaToControl(detail))
              case 8 =>
                Instruction(Key.BackSpace, location,   metaToControl(detail))
              case 9 =>
                Instruction(Key.Tab, location,         metaToControl(detail))
              case 25 => // OS/X maps
                Instruction(Key.Tab, location,         metaToControl(detail))
              case 127 =>
                Instruction(Key.Delete, location,      metaToControl(detail))
              case _ if detail.hasControl || detail.hasMeta || (location == Key.Location.Numpad && numpadAsCommand) =>
                // Linux and OS/X are consistent about e.KeyCode from a numpad, but not about e.getExtendKeyCode
                if (logging) finest(f"Defined keyChar: $keyString $location (\\x$keyCode%04x$detail%s)")
                Instruction(Key(keyCode), location,    metaToControl(detail))
              case _ =>
                if (detail.hasAlt) {
                  if (logging) finer(s"Alt-shifted $keyString $location $keyCode ${e.getExtendedKeyCode}")
                  if (macKeyboardDiacritical.contains(keyChar))
                    Diacritical(keyChar)
                  else
                    Character(altKeyChar.getOrElse(shifted(keyCode, detail.hasShift), keyChar), location, metaToControl(detail))
                }
                //
                else
                  Character(keyChar, location, metaToControl(detail))
            }
          if (logging)
            fine(s"==> $decoded")

          keystrokeInput.notify(decoded)
        }
      }}
  }




  /////////////////////// HANDLING COMPONENT-RESIZE EVENTS //////

  /** Invoked when this component has been resized. */
  protected def componentResized(): Unit

  locally {
    peer addComponentListener new ComponentAdapter {
      override def componentResized(e: ComponentEvent): Unit =
         InputPanel.this.componentResized()
    }
  }

  /////////////////////// HANDLING FOCUS EVENTS /////////////////

  /** The pointer image shown on this component the surface of
   *  this component when it has the focus: by default an "I-Beam"
   */
  protected val FocussedCursorImage: Cursor = {
    import java.awt.Cursor
    Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR)
  }

  /** The pointer image shown on this component the surface of
   *  this component when it does not have the focus: by default the system
   *  default cursor.
   */
  protected val UnfocussedCursorImage: Cursor = {
    import java.awt.Cursor
    Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR)
  }

  override def requestFocusInWindow(): Boolean = {
    peer.grabFocus()
    val r = peer.requestFocusInWindow()
    if (logging) finer(s"requestFocusinWindow()=$r")
    r
  }

  /** Invoked when this component gains (or loses)
   * the input focus. The standard response to these events is
   * to repaint the component after setting the cursor image
   * to one of  `{Focussed/Unfocussed}CursorImage`, and to
   * grab (or relinquish) the swing standard
   * focus-traversal keys (TAB/BACKTAB) that would
   * otherwise be pre-emptively acted upon by Swing.
   */
  protected def focusChanged(hasFocus: Boolean): Unit = {
    if (logging) finer(s"$this . focusChanged ($hasFocus)")
    hasFocus match {
      case true  =>
        // Technicality: grab focus-changing keystrokes (TAB/BACKTAB)
        peer.setFocusTraversalKeysEnabled(false)
        // Show the text-editing cursor image )(
        peer.setCursor(FocussedCursorImage)
        repaint()

      // This component lost the keyboard/mouse focus to another or to the system
      case false =>
        // Technicality: relinquish focus-changing keystrokes (TAB/BACKTAB)
        peer.setFocusTraversalKeysEnabled(true)
        // Show the generic cursor image
        peer.setCursor(UnfocussedCursorImage)
        repaint()
    }
  }

  locally {
    /*
       Swing KeyboardFocus should let this component request focus,
       but should ignore focus traversal keys
    */

    listenTo(this)
    reactions += {
      case FocusGained(self, other, temp) => {
        focusChanged(self.hasFocus)
        //if (logging) finer(s"FocusGained($self, $other, $temp)")
      }
      case FocusLost(self, other, temp) => {
        focusChanged(self.hasFocus)
        //if (logging) finer(s"FocusLost($self, $other, $temp)")
      }
    }
    peer.setFocusable(true);
    peer.setRequestFocusEnabled(true);
  }
  
  /** (Defined in subclasses): map the location of a mouse event
   *  relative to this component, to its  `(row, col)` coordinates
   *  relative to the model being displayed in this component.
   */
  protected def viewToModel(location: java.awt.Point): (Int, Int) // (row, col)

  /////////////////////////// HANDLING MOUSE EVENTS ///////////////////////

  private object Mouse {
    import java.awt.event.{MouseAdapter, MouseEvent, MouseMotionAdapter}

    // Report presses, releases, enters, exits
    val listener: MouseAdapter = new MouseAdapter {
      override def mousePressed(e: MouseEvent): Unit = {
        // The mouse was pressed (perhaps more than once)
        val clicks      = e.getClickCount
        val (row, col)  = viewToModel(e.getPoint)
        val modifiers   = e.getModifiersEx
        mouseInput.notify(MousePressed(row, col, clicks, metaToControl(Detail(modifiers))))
      }

      override def mouseReleased(e: MouseEvent): Unit = {
        // A mouse button was released
        /* OS/X Java uses alt/ctrl/meta keys
         * to encode the button, as well as reporting the
         * released button -- so we must not use these
         * modifiers-keys-proper when reporting from
         * here.
         */
        val (row, col)  = viewToModel(e.getPoint)
        val button      = e.getButton match {
          case 1 => Modifiers.Button1
          case 2 => Modifiers.Button2
          case 3 => Modifiers.Button3
          case _ => Modifiers.NoModifier // TODO: Log this
        }
        if (logging) finest(s"Released(($row,$col), ${e.getButton}) ${metaToControl(Detail(e.getModifiersEx))}")
        // TODO: need to be able to work with >3-button mice
        mouseInput.notify(MouseReleased(row, col, button))
      }
      
      override def mouseEntered(e: MouseEvent): Unit = {
        InputPanel.this.mouseEntered()
      }

      override def mouseExited(e: MouseEvent): Unit = {
        InputPanel.this.mouseExited()
      }
    }

    // Report mouse dragging
    val motionListener: MouseMotionAdapter = new MouseMotionAdapter {
       override def mouseDragged(e: MouseEvent): Unit = {
         val (row, col)  = viewToModel(e.getPoint)
         val modifiers   = e.getModifiersEx
         mouseInput.notify(MouseDragged(row, col, metaToControl(Detail(modifiers))))
       }
    }

    // Report mouse wheel rotation over this component
    peer addMouseWheelListener {
      case e: MouseWheelEvent =>
        mouseWheel(e.getWheelRotation, metaToControl(Detail(e.getModifiersEx)))
    }
  }

  /** Invoked when the mouse enters this component.
   * Default effect is to request the focus.
   */
  protected def mouseEntered(): Unit = requestFocusInWindow()

  /** Invoked when the mouse leaves this component.
   * Default effect is to do nothing
   */
  protected def mouseExited(): Unit = {}

  /**
   *  Invoked when the mouse wheel is rotated
   */
  protected def mouseWheel(rotation: Int, modifiers: Detail): Unit
}


object InputPanel extends Logging.Loggable {

}

