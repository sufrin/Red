package Red

import java.awt.Cursor
import java.awt.event.{ComponentAdapter, ComponentEvent, FocusEvent, FocusListener, KeyAdapter, MouseWheelEvent}
import java.awt.event.KeyEvent._
import scala.collection.mutable
import scala.swing.{Component, Container}

/**
 * A `Panel` that:
 *
 * 1. adapts the standard swing keystroke event
 * machinery for use by our (simpler) `UserInput`
 * notification and handling machinery.
 *
 * 2. adapts the standard swing mouse event machinery
 * for use by our (simpler) `UserInput`
 * handling machinery.
 *
 * 3. handles sensibly (by internally defined
 * overrideable defaults) the most common events generated
 * on it by focus and size change events.
 *
 * '''Operation:'''
 *
 * `keyPressed` events are captured early, independently of
 * `scala.swing` then translated  directly into
 * `UserInput.Instruction`s or `UserInput.Character`s that are
 * notified from its `keystrokeInput: Notifier[UserInput]`.
 * These can be handled directly by client programs using
 * `UserInputHandler`s.
 *
 * The benefits of this adaptation are:
 *
 * 1. (The many) irrelevant `KeyEvent`s reported by the
 *    underlying `java.swing` toolkit are
 *    just ignored.
 *
 * 2. "well-known" instruction keys (delete, rubout, tab, etc) --
 *    usually, but not always,  delivered as ascii keys in the control-character
 *    range -- are consistently translated into `UserInput.Instruction`s.
 *
 * 3. A large variety of keystrokes are distinguished, and this
 *    means that individual users' tastes in keyboard layout
 *    can very frequently be catered for.  Although the present
 *    implementation is intended to support a systematic approach
 *    to keyboard layout, there is no reason
 *    why keystrokes that are initially mapped to `Instruction`s
 *    cannot be mapped to character insertions by clients.
 *
 *
 *
 * Any modifier keys (Alt, Meta, Shift, Control, ...) or buttons down at the time of a
 * keystroke are passed on as part of the `modifiers` field of the `Instruction` or
 * `Character`. This has the value type `UserInputDetail.Detail`, and that type has a rich
 * set of methods for interrogating them, as well as constants that can be used
 * in straightfoward matching.
 *
 * The same holds holds for the reporting of mouse events.
 *
 * It is assumed that any keys typed with a `Control` or
 * `Meta` (OS/X=Cmd) modifier key down are intended to denote
 * `Instruction`s  whether or not any other modifier
 * key (Shift or Alt) is down.
 *
 *
 * '''Rationale'''
 *
 * 1. The (antiquated) Java scheme for handling keyboard events is confusing
 *    and hard to use -- perhaps unsurprising in light of the variety
 *    of keyboards and keyboard encodings it must handle, and the
 *    numbers of operating systems for which it has to maintain a
 *    semblance of consistent behaviour.
 *
 *    The `scala.swing` adoption of this model inherits many of the
 *    most confusing aspects of the design, though its (admirable)
 *    publisher machinery is an advance on the Java scheme.
 *
 * 2. The remaining interesting events generated by Panels are
 *    also handled here so as to enable client programs to be
 *    be built straightforwardly without having to use both
 *    the scala.swing publication model and our
 *    preferred, somewhat simpler, model of `UserInput` events
 *    notified from typed `Notifier`s, and
 *    handled by `UserInputHandler`s.
 *
 * @param numPadAsCommand Treat the numeric keypad (to the right of the
 *                        normal keyboard on some larger keyboards) as
 *                        a source of `Instruction`s rather than
 *                        `Character`s.
 *
 *
 * @param mapMeta  When this is true, the `Meta` (OS/X "Cmd") and
 *                  `Control` modifiers are both mapped to `Control`.
 *                  This simplifies the design of OS-agnostic
 *                  keystroke handlers in clients, at the expense of
 *                  limiting the number of distinct `Instruction`s
 *                  available to them.
 *
 * @param mergeMouseInput When true (the default), mouse and keyboard
 *                        input events are both notified from the `keystrokeInput`
 *                        `Notifier`.
 *
 *
 *
 */


abstract class InputPanel(val numPadAsCommand: Boolean = true,
                          val mapMeta:         Boolean = true,
                          val mergeMouseInput: Boolean = true,
                          )
  extends Component
     with Container.Wrapper {

  import InputPanel._
  import UserInputDetail._

  /** Link to an underlying `javax.swing.JPanel` to provide most
   *  of the functionality of this component
   */
  override lazy val peer: javax.swing.JPanel = new javax.swing.JPanel with SuperMixin

  locally { peer.setFont(font) }

  /** When true, the numeric keypad is treated as a source of `Instruction`s
   * rather than `Character`s.
   */
  var numpadAsCommand: Boolean = true

  /**
   * Transform the given event `modifier` bits so that  the `Meta`
   *  bit (OS/X `Cmd`) is mapped directly to the `Control` bit iff
   *  the component was constructed in `mapMeta` mode. In this
   *  mode the `Meta` and `Control` shifts cannot be distinguished,
   *  they are both reported as a `Control` shift.
   */
  private def metaToControl(detail: Detail): Detail =
          if (mapMeta) detail.mapMeta else detail


  /**
   * Notifier of the details of keystrokes made when
   * this `Component` has the input focus.
   *
   * Here are some examples of keystrokes and the corresponding `UserInput`
   * that gets notified, via `keystrokeInput`.
   * {{{
   * KEY    keyChar       Notified      (modifiers.asText)+
   *                      Class         Key (or character)
   * -------------------------------------------------------
   * A      'a'        => Character     'a'
   * B      'b'        => Character     'b'
   *
   * ctrl+A '\u0001'   => Instruction   control +Key.A
   * meta+A 'a'        => Instruction   meta+Key.A
   * meta+E 'e'        => Instruction   meta+Key.E
   * X      'x'        => Character     'x'
   * C      'c'        => Character     'c'
   * meta+X 'x'        => Instruction   meta+Key.X
   * X      'x'        => Character     'x'
   * F1                => Instruction   Key.F1
   * F2                => Instruction   Key.F2
   * ctrl+F1           => Instruction   control +Key.F1
   * alt+F3            => Instruction   alt+Key.F3
   * ctrl-alt+F3       => Instruction   control +alt+Key.F3
   *
   * On OS/X with a standard British keymap (and an empty `altKeyChar`) map
   * alt+X  '≈'        => Character alt+'≈' // OS/X British
   * alt+C 'ç'         => Character alt+'ç' // OS/X British
   * alt+meta+X '≈'    => Instruction alt+meta+X
   * }}}
   *
   * Decodings of keys typed on/at the numeric pad
   * {{{
   * NumPad-1       '1'      => Instruction Numpad1
   * NumPad-2       '2'      => Instruction Numpad2
   * ctrl+NumPad-0  '0'      => Instruction control+Numpad0
   * ctrl+NumPad .  '.'      => Instruction control+NumPad .
   * ctrl+Enter     '\u000a' => Instruction control+Enter
   * ctrl+NumPad +  '+'      => Instruction control+Add
   * }}}
   */
  val keystrokeInput: Notifier[UserInput] = new Notifier[UserInput] {
    override def enableResources(): Unit = {
      peer.addKeyListener(Keyboard.listener)
      if (mergeMouseInput) {
        peer.addMouseListener(Mouse.listener)
        peer.addMouseMotionListener(Mouse.motionListener)
      }
    }
    override def disableResources(): Unit = {
      peer.removeKeyListener(Keyboard.listener)
      if (mergeMouseInput) {
        peer.removeMouseListener(Mouse.listener)
        peer.removeMouseMotionListener(Mouse.motionListener)
      }
    }
  }

  /**  Notifier of (most of the) mouse inputs made when this
   * component has the input focus.
   */
  val mouseInput:      Notifier[UserInput]  =
    if (mergeMouseInput) keystrokeInput else new Notifier[UserInput] {
      override def enableResources(): Unit = {
        peer.addMouseListener(Mouse.listener)
        peer.addMouseMotionListener(Mouse.motionListener)
      }
      override def disableResources(): Unit = {
        peer.removeMouseListener(Mouse.listener)
        peer.removeMouseMotionListener(Mouse.motionListener)
      }
    }


  /////////////////////////// HANDLING KEYSTROKES ///////////////////////

  private object Keyboard {
    // Bypass the `scala.swing.event` machinery for reporting keystrokes
    val listener: KeyAdapter = new KeyAdapter() {
      override def keyPressed(e: java.awt.event.KeyEvent): Unit = {
        val keyChar   = e.getKeyChar
        val modifiers = e.getModifiersEx
        val detail    = Detail(modifiers)
        val location  = Key.Location(e.getKeyLocation)
        val keyCode   = e.getKeyCode
        val exKeyCode = e.getExtendedKeyCode
        if (logging)
          finest(s"'$keyChar' $modifiers $location $keyCode  $exKeyCode")
        if (e.isActionKey) {
          // one of the "standard" function keys
          val decoded =
              Instruction(Key(exKeyCode), location, metaToControl(detail))
          if (logging)
             fine(s"==> $decoded")
          keystrokeInput.notify(decoded)
        } else if (keyChar != CHAR_UNDEFINED) {
          // a character: not just a modifier-shift being pressed
          val decoded =
            keyChar match {
              case 27 =>
                Instruction(Key.Escape, location,      metaToControl(detail))
              case 8 =>
                Instruction(Key.BackSpace, location,   metaToControl(detail))
              case 9 =>
                Instruction(Key.Tab, location,         metaToControl(detail))
              case 25 => // OS/X maps
                Instruction(Key.Tab, location,         metaToControl(detail))
              case 127 =>
                Instruction(Key.Delete, location,      metaToControl(detail))
              case _ if detail.hasControl || detail.hasMeta || (location == Key.Location.Numpad && numpadAsCommand) =>
                // Linux and OS/X are consistent about e.KeyCode from a numpad, but not about e.getExtendKeyCode
                Instruction(Key(keyCode), location,    metaToControl(detail))
              case _ =>
                if (detail.hasAlt) {
                  if (logging) finer(s"Alt-shifted '$keyChar' ${detail.asText} $location $keyCode ${e.getExtendedKeyCode}")
                  Character(altKeyChar.getOrElse(shifted(keyCode, detail.hasShift), keyChar), location, metaToControl(detail))
                }
                //
                else
                  Character(keyChar, location, metaToControl(detail))
            }
          if (logging)
            fine(s"==> $decoded")
          keystrokeInput.notify(decoded)
        }
      }}
  }


  //
  //
  //      TL;DR
  //
  //

  private val mathTrans = List(
    unshifted('A') -> '\u03b1', // alpha
    unshifted('B') -> '\u03b2', // beta
    unshifted('C') -> '\u03b3', // gamma
    shifted('C') -> '\u0393',   // GAMMA
    unshifted('D') -> '\u03b4', // delta
    shifted('D') -> '\u0394',   // DELTA
    unshifted('E') -> '\u03b5',
    unshifted('F') -> '\u03b6',
    unshifted('G') -> '\u03b7',
    unshifted('H') -> '\u03b8',
    shifted('H') -> '\u0398',  // THETA
    unshifted('I') -> '\u03b9',
    unshifted('J') -> '\u03b9',
    unshifted('K') -> '\u03ba',
    unshifted('L') -> '\u03bb',
    shifted('L') -> '\u039b',  // LAMBDA
    unshifted('M') -> '\u03bc',
    unshifted('N') -> '\u03bd',
    unshifted('Z') -> '\u03be', // Zeta
    unshifted('O') -> '\u03bf',
    unshifted('P') -> '\u03c0',
    unshifted('Q') -> '\u03c2',
    unshifted('R') -> '\u03c1',  // Rho
    unshifted('S') -> '\u03C3',  // Sigma
    shifted('S')   -> '\u03A3',  // SIGMA
    unshifted('T') -> '\u03C4',  // Tau
    unshifted('U') -> '\u03C5',  // Nu
    unshifted('V') -> '\u03C6',  // Phi
    unshifted('W') -> '\u03C9',  // omega
    unshifted('X') -> '\u03C7',  // xi
    unshifted('Y') -> '\u03C8',  // Psi
    unshifted('Z') -> '\u03C9',
    shifted('=') -> '\u2262',   // IDENTICAL TO
    unshifted('=') -> '\u2261'  // NOT IDENTICAL TO
  )
  /**
   * Supplementary mapping of keycodes to characters: applied
   * only when  `Alt` or `Alt+Shift`  are in effect. This may be
   * changed ad-lib; it is initialized to a mapping from the roman
   * alphabet to corresponding greek symbols.
   *
   * '''Warning:'''
   *
   * What follows is only for the very intrepid or the very desperate. Most
   * application programmers using a `InputPanel` will not need to stray into
   * any of the detailed explanation below.
   *
   * '''Detail'''
   *
   * Most operating systems provide for customization of the mapping
   * between physical keys and logical characters. Many of the
   * methods involve keystrokes made with an `Alt`-shift, and here
   * we only attempt to address these.
   *
   * Characters typed with only  `Alt` or  `Alt+Shift` in effect are
   * treated specially:
   *
   * 1. It is assumed (as a first approximation) that the underlying
   * operating system has handled decoding of keys typed with `Alt` down,
   * and that the resulting character codes are intended to denote
   * ordinary Unicode `Character`s.
   *
   * 2. This assumption is sound for OS/X, but is currently known
   * not to be satisfied by many popular Linux variants. Moreover
   * even in OS/X it can be a lot of trouble to find, or
   * to use system facilities to craft, a mapping from the
   * physical keys on a keyboard to (Unicode) characters
   * -- if they happen to be outside a conventional alphabet.
   *
   * The `altKeyChar` mapping is used to override the parts of
   * the physical key to unicode mapping for which it is defined.
   * A character that was typed with the alt modifier down is returned
   * as a `Character` translated, as below, using this mapping
   *
   * {{{
   * val char =
   *   altKeyChar.getOrElse(shifted(keyCode,mods.hasShift),keyChar)
   * Character(char, location, mods)
   * }}}
   *
   * A ''physical key'' is specified as either `shifted`''(c)''
   * or `unshifted`''(c)'', where ''c'' is the letter on the
   * keytop. Here's a little example of the construction and
   * installation of such a mapping.
   *
   * Note that shifted/unshifted arguments are
   * letters marked on keytops (upper case)
   * {{{
   * altKeyChar = new HashMap[Int, Char]().addAll(List(
   *  unshifted('A') -> '\u03b1', // alpha
   *  unshifted('B') -> '\u03b2', // beta
   *  unshifted('C') -> '\u03b3', // gamma
   *  shifted('C') -> '\u0393',   // GAMMA
   *  unshifted('D') -> '\u03b4', // delta
   *  shifted('D') -> '\u0394',   // DELTA
   *  ))
   * }}}
   *
   * '''Advice'''
   * It is a good idea to use `altKeyChar` maps sparingly.
   * There are much better, though a bit more prolix, ways of
   * typing "exotic" symbols and sequences conveniently; one of which
   * is provided in the "abbreviation" facility of the complete
   * `Red` editor.
   */
  var altKeyChar: mutable.Map[Int, Char] = new mutable.HashMap[Int, Char]().addAll(mathTrans)

  /////////////////////// HANDLING COMPONENT-RESIZE EVENTS //////

  /** Invoked when this component has been resized. */
  protected def componentResized(): Unit

  locally {
    peer addComponentListener new ComponentAdapter {
      override def componentResized(e: ComponentEvent): Unit =
         InputPanel.this.componentResized()
    }
  }

  /////////////////////// HANDLING FOCUS EVENTS /////////////////

  /** The pointer image shown on this component the surface of
   *  this component when it has the focus: by default an "I-Beam"
   */
  protected val FocussedCursorImage: Cursor = {
    import java.awt.Cursor
    Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR)
  }

  /** The pointer image shown on this component the surface of
   *  this component when it does not have the focus: by default the system
   *  default cursor.
   */
  protected val UnfocussedCursorImage: Cursor = {
    import java.awt.Cursor
    Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR)
  }

  /** Invoked when this component gains (or loses)
   * the input focus. The standard response to these events is
   * to repaint the component after setting the cursor image
   * to one of  `{Focussed/Unfocussed}CursorImage`, and to
   * grab (or relinquish) the swing standard
   * focus-traversal keys (TAB/BACKTAB) that would
   * otherwise be pre-emptively acted upon by Swing.
   */
  protected def focusChanged(hasFocus: Boolean): Unit = {
    hasFocus match {
      case true  =>
        // Technicality: grab focus-changing keystrokes (TAB/BACKTAB)
        peer.setFocusTraversalKeysEnabled(false)
        // Show the text-editing cursor image )(
        peer.setCursor(FocussedCursorImage)
        repaint()

      // This component lost the keyboard/mouse focus to another or to the system
      case false =>
        // Technicality: relinquish focus-changing keystrokes (TAB/BACKTAB)
        peer.setFocusTraversalKeysEnabled(true)
        // Show the generic cursor image
        peer.setCursor(UnfocussedCursorImage)
        repaint()
    }
  }

  locally {
    peer addFocusListener new FocusListener {
      override def focusGained(e: FocusEvent): Unit = focusChanged(true)
      override def focusLost(e: FocusEvent): Unit   = focusChanged(false)
    }
  }
  
  /** (Defined in subclasses): map the location of a mouse event
   *  relative to this component, to its  `(row, col)` coordinates
   *  relative to the model being displayed in this component.
   */
  protected def viewToModel(location: java.awt.Point): (Int, Int) // (row, col)

  /////////////////////////// HANDLING MOUSE EVENTS ///////////////////////

  private object Mouse {
    import java.awt.event.{MouseAdapter, MouseEvent, MouseMotionAdapter}

    // Report presses, releases, enters, exits
    val listener: MouseAdapter = new MouseAdapter {
      override def mousePressed(e: MouseEvent): Unit = {
        // The mouse was pressed (perhaps more than once)
        val clicks      = e.getClickCount
        val (row, col)  = viewToModel(e.getPoint)
        val modifiers   = e.getModifiersEx
        mouseInput.notify(MousePressed(row, col, clicks, metaToControl(Detail(modifiers))))
      }

      override def mouseReleased(e: MouseEvent): Unit = {
        // The mouse was released
        val (row, col)  = viewToModel(e.getPoint)
        val modifiers   = e.getModifiersEx
        mouseInput.notify(MouseReleased(row, col, metaToControl(Detail(modifiers))))
      }

      override def mouseEntered(e: MouseEvent): Unit =
        InputPanel.this.mouseEntered()

      override def mouseExited(e: MouseEvent): Unit =
        InputPanel.this.mouseExited()
    }

    // Report mouse dragging
    val motionListener: MouseMotionAdapter = new MouseMotionAdapter {
       override def mouseDragged(e: MouseEvent): Unit = {
         val (row, col)  = viewToModel(e.getPoint)
         val modifiers   = e.getModifiersEx
         mouseInput.notify(MouseDragged(row, col, metaToControl(Detail(modifiers))))
       }
    }

    // Report mouse wheel rotation over this component
    peer addMouseWheelListener {
      case e: MouseWheelEvent =>
        mouseWheel(e.getWheelRotation, metaToControl(Detail(e.getModifiersEx)))
    }
  }

  /** Invoked when the mouse enters this component.
   * Default effect is to request the focus.
   */
  protected def mouseEntered(): Unit = requestFocusInWindow()

  /** Invoked when the mouse leaves this component.
   * Default effect is to do nothing
   */
  protected def mouseExited(): Unit = {}

  /**
   *  Invoked when the mouse wheel is rotated
   */
  protected def mouseWheel(rotation: Int, modifiers: Detail): Unit
}


object InputPanel extends Logging.Loggable {
  /** An arbitrary bitpattern beyond Char.MaxValue */
  private val SHIFTED: Int = Char.MaxValue+1
  /** Local integer encoding of a character; used
   *  in constructing and decoding `altKeyChar` maps:
   *
   *  Yields an integer derived from `char`, distinct from
   *  any `Char`.toInt value; unless `shifted` is false, in
   *  which case it yields `char`
   */
  @inline def shifted(char: Int, shifted: Boolean=true): Int =
    if (shifted) SHIFTED|char else char

  /** Yields `char` (identical to `shifted(char, false)` */
  @inline def unshifted(char: Int): Int = char
}

